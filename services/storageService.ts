
import { RepairGuide, HistoryItem } from '../types';
import { supabase } from '../lib/supabaseClient';

export const getHistory = async (): Promise<HistoryItem[]> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return [];

  const { data, error } = await supabase
    .from('guides')
    .select('id, vehicle_json, guide_content_json, created_at')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching history:', error);
    return [];
  }

  // Map to HistoryItem
  return data.map((row) => {
    // vehicle_json and guide_content_json are stored as JSONB, so they come back as objects
    const vehicle = row.vehicle_json;
    const guide = row.guide_content_json;

    return {
      id: row.id,
      title: guide.title || 'Untitled Repair',
      vehicle: `${vehicle.year} ${vehicle.make} ${vehicle.model}`,
      timestamp: new Date(row.created_at).getTime(),
    };
  });
};

export const saveGuide = async (guide: RepairGuide): Promise<void> => {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    console.warn('User not logged in, cannot save guide to cloud.');
    return;
  }

  const { error } = await supabase
    .from('guides')
    .insert({
      user_id: user.id,
      vehicle_json: guide.vehicle, // Assuming guide.vehicle is the object
      guide_content_json: guide,   // Store full guide
    });

  if (error) {
    console.error('Error saving guide:', error);
    throw error;
  }
};

export const getGuideById = async (id: string): Promise<RepairGuide | null> => {
  // We can fetch a specific guide by ID. 
  // Note: The ID in the prototype was constructed from string. 
  // In Supabase, if we use UUIDs for primary keys, we might need to adjust.
  // But `guides` table definition in prompt said `id` (implied UUID or string). 
  // If we stick to generated IDs from the AI formatted string, we can use that as the ID column, 
  // OR strictly use UUIDs.
  // Prompt says "guides table (id, user_id...)". Usually ID is UUID.
  // However, the `guide.id` generated by `geminiService` is like `2010-honda-civic-brakes`.
  // Ideally we should use that as a partial key or store it.
  // Let's assume the ID column in Supabase is a String or UUID. 
  // If we want to retrieve by the AI-generated ID, we should query by a column (perhaps add one) or just `id`.
  // For now, I'll attempt to fetch by `id`.

  const { data, error } = await supabase
    .from('guides')
    .select('guide_content_json')
    .eq('id', id)
    .single();

  if (error || !data) {
    // Fallback: It might be a classic ID lookup issue if we switched ID strategies.
    // But following the prompt "When HistoryPage.tsx loads, fetch rows...", this function might need to support the ID from the history list.
    console.error('Error fetching guide by ID:', error);
    return null;
  }

  return data.guide_content_json as RepairGuide;
};
